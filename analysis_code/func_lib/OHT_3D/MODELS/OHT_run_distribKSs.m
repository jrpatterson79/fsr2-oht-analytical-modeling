function [run_result] = OHT_run_distribKSs(params,domain,bdrys,experiment,run_type)

%OHT_run_distribKSs: Function takes ln(K) and ln(Ss)
%values in a column vector and calculates either simulated observations,
%simulated phasor fields (representing real / imaginary components of phasor at all points
%within the model), or the sensitivity matrix. 
%
% Syntax:
%[run_result] = OHT_run_distribKSs(params,domain, bdrys, experiment,run_type)
%
%where:
% OUTPUTS:
%   -run_result is the result of the model run, consisting of either a set
%   of simulated observations, a full picture of the forward model phasor
%   field (representing real and imaginary components of the phasor  at all
%   points within the model), or a sensitivity matrix for the given
%   observations. The output type depends on the "run_type" input.
%       -Run_type 1: run_result is a vector, representing all of the real
%       coefficients of the phasor (for each observation) followed by the
%       imaginary coefficients of the phasor. If the number of observations
%       is numobs, then the output is a (2*numobs x 1) vector.
%       -Run_type 2: run_result is a vector, representing the real part of
%       the phasor values at all points in space, followed by the imaginary
%       parts of the phasor at all points in space. If there are numcells
%       cells in the numerical model, the output is a (2*numcells x 1)
%       vector.
%       -Run_type 3: run_result is a matrix, representing the sensitivity
%       of all observations to K and Ss values in all grid cells. Rows
%       consist of all real phasor part sensitivities, followed by all
%       imaginary phasor part sensitivities. Columns consist of sensitivity
%       to ln(K) in all model cells, followed by sensitivity to ln(Ss) in
%       all model cells. Matrix size is thus (2*numobs x 2*numcells)
% INPUTS:
%       -params is the set of all K and Ss values for the model, as a
%       vector with 2*numcells ln(K) and ln(Ss) values, ordered in the
%       standard format according to meshgrid and reshape conventions.
%       -domain is a structure containing fields x,y, and z that describe
%       the boundaries of domain grid cells
%       -bdrys is a structure containing fields types and vals, that
%       describe the type and values at the 6 boundaries.
%       -experiment is a structure containing all information about
%       testing, as generated by OHT_create_inputs.m. See documentation of
%       that function for further information.
%
% Code by Michael Cardiff, 2015-2016

%TODO: -Modify functionality to take params in a more intuitive
%way. 
%TODO: -Also, include information in bdry.leaks, pass to forward model
%function
%TODO: Modify functions that wrap around this (geostat inversion) to supply
%parameters in more intuitive way.

%Error checking, extract all needed information from structures
if ~isfield(domain,'x')
    error('X boundary information must be supplied in domain_disc.x');
else
    xb = domain.x;
end

if ~isfield(domain,'y')
    error('Y boundary information must be supplied in domain_disc.y');
else
    yb = domain.y;
end

if isfield(domain,'z')
    zb = domain.z;
else
    zb = [0 1];
end

bdry_types = bdrys.types;
bdry_vals = bdrys.vals;
bdry_leaks = [];
if isfield(bdrys,'leaks')
    bdry_leaks = bdrys.leaks;
end

num_omegas = size(experiment,1);
num_x = numel(xb)-1;
num_y = numel(yb)-1;
num_z = numel(zb)-1;
num_wt = num_x*num_y;
num_cells = num_x*num_y*num_z;

lnK = params(1:num_cells);
lnSs = params((num_cells+1):(2*num_cells));
lnK_mat = reshape(lnK,num_y,num_x,num_z);
lnSs_mat = reshape(lnSs,num_y,num_x,num_z);
lnSy = [];
lnSy_mat = [];
if numel(params) > (2*num_cells)
    lnSy = params((2*num_cells+1):(2*num_cells+num_wt));
    lnSy_mat = reshape(lnSy,num_y,num_x);
end

num_obs = zeros(num_omegas,1);
for i = 1:1:num_omegas
    num_obs(i) = size(experiment(i).tests,1);
end
num_totalobs = sum(num_obs);
cum_totalobs = [0; cumsum(num_obs)];

num_stims = zeros(num_omegas,1);
for i = 1:1:num_omegas
    num_stims(i) = size(experiment(i).stims,2);
end
num_totalstims = sum(num_stims);
cum_totalstims = [0; cumsum(num_stims)];

sim_obs = zeros(2*num_totalobs,1);
Phis = zeros(num_cells,num_totalstims);

if nargout == 2
    H = zeros(2*num_totalobs,2*num_cells);
end

for i = 1:1:num_omegas
    firstobs = cum_totalobs(i) + 1;
    lastobs = cum_totalobs(i+1);
    firststim = cum_totalstims(i) + 1;
    laststim = cum_totalstims(i+1);
    switch run_type
        case 1
            [sim_obs_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,exp(lnK_mat),exp(lnSs_mat),...
                xb,yb,zb,bdry_types,exp(lnSy_mat),bdry_leaks);
            sim_obs(firstobs:lastobs) = real(sim_obs_omega);
            sim_obs((num_totalobs+firstobs):(num_totalobs+lastobs)) = imag(sim_obs_omega);
            run_result = sim_obs;
        case 2
            [~,Phi_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,exp(lnK_mat),exp(lnSs_mat),...
                xb,yb,zb,bdry_types,exp(lnSy_mat),bdry_leaks);
            Phis(1:num_cells,firststim:laststim) = real(Phi_omega);
            Phis((num_cells+1):(2*num_cells),firststim:laststim) = imag(Phi_omega);
            run_result = Phis;
        case 3
            [~,~,H_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,exp(lnK_mat),exp(lnSs_mat),...
                xb,yb,zb,bdry_types,exp(lnSy_mat),bdry_leaks);
            %Convert sensitivity from wrt K and Ss to wrt ln(K) and ln(Ss)
            for j = 1:1:num_obs
                H_omega{1}(j,:) = H_omega{1}(j,:).*exp(lnK)';
                H_omega{2}(j,:) = H_omega{2}(j,:).*exp(lnSs)';
                if ~isempty(lnSy)
                    H_omega{3}(j,:) = H_omega{3}(j,:).*exp(lnSy)';
                end
            end
            if ~isempty(lnSy)
                H(firstobs:lastobs,:) = real([H_omega{1} H_omega{2} H_omega{3}]);
                H((num_totalobs+firstobs):(num_totalobs+lastobs),:) = imag([H_omega{1} H_omega{2} H_omega{3}]);
            else
                H(firstobs:lastobs,:) = real([H_omega{1} H_omega{2}]);
                H((num_totalobs+firstobs):(num_totalobs+lastobs),:) = imag([H_omega{1} H_omega{2}]);
            end
            run_result = H;            
        otherwise
            error('Only run type of 1, 2, or 3 is supported');
    end
end
