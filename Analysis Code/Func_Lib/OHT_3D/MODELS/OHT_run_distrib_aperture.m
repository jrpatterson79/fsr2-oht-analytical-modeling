function [run_result] = OHT_run_distrib_aperture(params,domain,bdrys,experiment,run_type,varargin)

%OHT_run_distrib_aperture: Function takes ln(aperture) values in a column
%vector and calculates either simulated observations, simulated phasor
%fields (representing real / imaginary components of phasor at all points
%within the model), or the sensitivity matrix for a 2-D test in a fracture.
%
% Syntax:
%[run_result] = OHT_run_distrib_aperture(params,domain, bdrys, experiment,run_type,[water_params])
%
%where:
% OUTPUTS:
%   -run_result is the result of the model run, consisting of either a set
%   of simulated observations, a full picture of the forward model phasor
%   field (representing real and imaginary components of the phasor  at all
%   points within the model), or a sensitivity matrix for the given
%   observations. The output type depends on the "run_type" input.
%       -Run_type 1: run_result is a vector, representing all of the real
%       coefficients of the phasor (for each observation) followed by the
%       imaginary coefficients of the phasor. If the number of observations
%       is numobs, then the output is a (2*numobs x 1) vector.
%       -Run_type 2: run_result is a vector, representing the real part of
%       the phasor values at all points in space, followed by the imaginary
%       parts of the phasor at all points in space. If there are numcells
%       cells in the numerical model, the output is a (2*numcells x 1)
%       vector.
%       -Run_type 3: run_result is a matrix, representing the sensitivity
%       of all observations to aperture in all grid cells. Rows
%       consist of all real phasor part sensitivities, followed by all
%       imaginary phasor part sensitivities. Columns consist of sensitivity
%       to ln(aperture) in all model cells. Matrix size is thus (2*numobs x
%       numcells)
% INPUTS:
%       -params is the set of all apertures for the model, as a vector with
%       numcells ln(aperture) values, ordered in the standard format
%       according to meshgrid and reshape conventions.
%       -domain is a structure containing fields x,y, and z that describe
%       the boundaries of domain grid cells. For this code, z is considered
%       unitless, and the boundaries of the z dimension must be [0 1]
%       -bdrys is a structure containing fields types and vals, that
%       describe the type and values at the 6 boundaries.
%       -experiment is a structure containing all information about
%       testing, as generated by OHT_create_inputs.m. See documentation of
%       that function for further information.
%       -[water_params] (optional) is a vector of values to be used for
%       gravity and physical properties of water. This should be supplied
%       as a 4 x 1 vector with the following elements:
%           1: Fluid density in kg/m^3
%           2: Fluid dynamic viscosity in Pa*s
%           3: Fluid compressibility in 1/Pa
%           4: Gravitational acceleration in m/s^2
%
% Code by Michael Cardiff, 2015-2022

nreqin = 5;
property_vec = [];
if nargin > nreqin
    property_vec = varargin{1};
end

%Error checking, extract all needed information from structures
if ~isfield(domain,'x')
    error('X boundary information must be supplied in domain_disc.x');
else
    xb = domain.x;
end

if ~isfield(domain,'y')
    error('Y boundary information must be supplied in domain_disc.y');
else
    yb = domain.y;
end

if isfield(domain,'z')
    zb = domain.z;
else
    zb = [0 1];
end

bdry_types = bdrys.types;
bdry_vals = bdrys.vals;

num_omegas = size(experiment,1);
num_x = numel(xb)-1;
num_y = numel(yb)-1;
num_z = numel(zb)-1;
num_cells = num_x*num_y*num_z;

if (num_z > 1) || ~all(zb == [0 1])
    error(['This code deals with fracture aperture and thus assumes ', ...
        'a single layer with unitless thickness z = 1 [-]. Other domain', ...
        'dimensions in z are not allowed']);
end

%Default values for fluid properties and gravity.
rho_f = 998.23; %Density, kg/m^3
mu_f = 1.0016E-3; %Viscosity, Pa*s
C_f = 1./(2.1e9); %Compressibility, 1/Pa 
g = 9.81; %Gravitational constant, m/s^2
%If user-supplied values are given, use them
if ~isempty(property_vec)
    rho_f = property_vec(1);
    mu_f = property_vec(2);
    C_f = property_vec(3);
    g = property_vec(4);
end

lnaper = params(1:num_cells);
aper = exp(lnaper);
T_vec = rho_f.*g.*aper.^3./(12.*mu_f);
S_vec = rho_f.*g.*C_f.*aper;

T_mat = reshape(T_vec,num_y,num_x,num_z);
S_mat = reshape(S_vec,num_y,num_x,num_z);

num_obs = zeros(num_omegas,1);
for i = 1:1:num_omegas
    num_obs(i) = size(experiment(i).tests,1);
end
num_totalobs = sum(num_obs);
cum_totalobs = [0; cumsum(num_obs)];

num_stims = zeros(num_omegas,1);
for i = 1:1:num_omegas
    num_stims(i) = size(experiment(i).stims,2);
end
num_totalstims = sum(num_stims);
cum_totalstims = [0; cumsum(num_stims)];

sim_obs = zeros(2*num_totalobs,1);
Phis = zeros(num_cells,num_totalstims);
H = zeros(2*num_totalobs, num_cells);

for i = 1:1:num_omegas
    firstobs = cum_totalobs(i) + 1;
    lastobs = cum_totalobs(i+1);
    firststim = cum_totalstims(i) + 1;
    laststim = cum_totalstims(i+1);
    switch run_type
        case 1
            [sim_obs_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,T_mat,S_mat,...
                xb,yb,zb,bdry_types);
            sim_obs(firstobs:lastobs) = real(sim_obs_omega);
            sim_obs((num_totalobs+firstobs):(num_totalobs+lastobs)) = imag(sim_obs_omega);
            run_result = sim_obs;
        case 2
            [~,Phi_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,T_mat,S_mat,...
                xb,yb,zb,bdry_types);
            Phis(1:num_cells,firststim:laststim) = real(Phi_omega);
            Phis((num_cells+1):(2*num_cells),firststim:laststim) = imag(Phi_omega);
            run_result = Phis;
        case 3
            [~,~,H_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,T_mat,S_mat,...
                xb,yb,zb,bdry_types);
            %Convert sensitivity from wrt K and Ss to wrt aperture
            %(combination effect)
            for j = 1:1:num_obs(i)
                %Component 1 - dobs/dT * dT/daperture
                H_omega{1}(j,:) = H_omega{1}(j,:).*3.*T_vec';
                %Component 2 - dobs/dS * dS/daperture
                H_omega{2}(j,:) = H_omega{2}(j,:).*S_vec';
            end
            H(firstobs:lastobs,:) = real(H_omega{1} + H_omega{2});
            H((num_totalobs+firstobs):(num_totalobs+lastobs),:) = imag(H_omega{1} + H_omega{2});
            run_result = H;            
        otherwise
            error('Only run type of 1, 2, or 3 is supported');
    end
end
